<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  <link href='http://fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.3"/>




  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.3" />



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    analytics: {
      google: ''
    },
    sidebar: 'post'
  };
</script>




  <title> ZhaoWei's Blog </title>
</head>

<body>
  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->

  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">ZhaoWei's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<div class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/">
            <i class="menu-item-icon icon-home"></i> <br />
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            <i class="menu-item-icon icon-archives"></i> <br />
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            <i class="menu-item-icon icon-tags"></i> <br />
            標籤
          </a>
        </li>
      
    </ul>
  

  
</div>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/04/sort_part1/">
                排序算法----基于比较的排序
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-07-04
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/数据结构和算法/">数据结构和算法</a>

              
              

            
          </span>
        

        
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h3 id="插入排序">插入排序</h3><p>插入排序的原理很简单很简单，打扑克牌时理牌的思想就是插入排序。</p>
<pre><code><span class="keyword">void</span> InsertionSort(<span class="built_in">int</span> A[], <span class="built_in">int</span> n){  <span class="comment">//对大小为n的整型数组进行排序</span>
  <span class="built_in">int</span> i,j;
  <span class="built_in">int</span> <span class="variable">key</span>;
  <span class="comment">//从第二个元素开始，边比较边移动 </span>
  <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++){
    j=i-<span class="number">1</span>;
    <span class="variable">key</span>=A[i];
    <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; A[j]&gt;<span class="variable">key</span>){
    A[j+<span class="number">1</span>]=A[j];
      j--;
    }
    A[j+<span class="number">1</span>]=<span class="variable">key</span>;
  }    
}   
</code></pre><p>插入排序算法的时间复杂度为O(N^2)，空间复杂度为O(1)，排序稳定。</p>
<h3 id="归并排序">归并排序</h3><p>归并排序利用了分治的思想，先把待排序数组分成两个字数组，子数组排好序后，合并成一个排好序的大数组，而子数组的排序可以递归的调用归并排序算法本身。  </p>
<p>归并排序的关键在于归并过程： </p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span></span>{
  <span class="keyword">int</span> n1=q-p+<span class="number">1</span>;
  <span class="keyword">int</span> n2=r-q;
  <span class="keyword">int</span> i,j,k;
  <span class="comment">//创建两个数组，分别保存待合并的左边和右边的数组。</span>
  <span class="keyword">int</span> *arr1=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>((n1+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));
  <span class="keyword">int</span> *arr2=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>((n2+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));
  <span class="comment">//复制原数组到元素到新创建的数组。</span>
  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n1;i++)  arr1[i]=A[p+i];
  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n2;i++)  arr2[i]=A[q+<span class="number">1</span>+i];
  <span class="comment">//这里关键处，设置了两个"哨兵牌"，简化了后面的归并程。</span>
  arr1[n1]=INT_MAX;
  arr2[n2]=INT_MAX;
  <span class="comment">//归并过程，由于有"哨兵"的存在，不需要判断i,j是否会分别大于n1,n2。</span>
  i=j=<span class="number">0</span>;
  <span class="keyword">for</span>(k=p;k&lt;=r;k++){
    <span class="keyword">if</span>(arr1[i]&lt;=arr2[j]){
      A[k]=arr1[i];
      i++;
    }
    <span class="keyword">else</span>{
      A[k]=arr2[j];
      j++;
    }     
  } 
}
</code></pre><p>利用归并过程对数组进行归并排序：</p>
<pre><code>void merge_sort(<span class="built_in">int</span> A[], <span class="built_in">int</span> low, <span class="built_in">int</span> high){
  <span class="keyword">if</span>(low&lt;high){
     <span class="built_in">int</span> <span class="built_in">mid</span>=(high+low)/<span class="number">2</span>;
     merge_sort(A,low,<span class="built_in">mid</span>);
     merge_sort(A,<span class="built_in">mid</span>+<span class="number">1</span>,high);
     Merge(A,low,<span class="built_in">mid</span>,high);
  }
}
</code></pre><p>归并排序函数：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span>{
  merge_sort(A,<span class="number">0</span>,n-<span class="number">1</span>);
}
</code></pre><p>归并排序算法的时间复杂度为O(N*logN),空间复杂度为O(N),排序稳定。</p>
<h3 id="堆排序">堆排序</h3><p>归并排序的时间复杂度比插入排序小，但是空间复杂度大，堆排序结合了两者的优点。<br>堆排序使用一种叫做(二叉)堆的数据结构，其可以被视作一颗完全二叉树。堆排序的主要过程为保持堆的性质。假设一棵完全二叉树除了根节点之外，其左右子树都是大顶堆，则保持整棵树为大顶堆的过程keep_max_heap为：</p>
<pre><code><span class="comment">//以i为根的二叉数的左右子树都为大顶堆。</span>
<span class="comment">//这个过程使以i为根的整棵树成为大顶堆。    </span>
<span class="function"><span class="keyword">void</span> <span class="title">keep_max_heap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> heap_size, <span class="keyword">int</span> n)</span></span>{ 
  <span class="keyword">int</span> l=<span class="number">2</span>*i; <span class="comment">//左子树的根</span>
  <span class="keyword">int</span> r=<span class="number">2</span>*i+<span class="number">1</span>; <span class="comment">//右子树的根</span>
  <span class="comment">//找出i,l,r值最大的结点</span>
  <span class="keyword">int</span> temp,largest=i;
  <span class="keyword">if</span>(l&lt;heap_size &amp;&amp; A[l]&gt;A[i]){
    largest=l;
  }
  <span class="keyword">if</span>(r&lt;heap_size &amp;&amp; A[r]&gt;A[largest]){
    largest=r;
  }
  <span class="comment">//若根非最大结点，将根的值与最大结点对换，然后递归调用自身保持子树的最大堆性质</span>
  <span class="keyword">if</span>(largest!=i){
    emp=A[i];
    A[i]=A[largest];
    A[largest]=temp;
    keep_max_heap(A,largest,heap_size,n);
  }
}
</code></pre><p>上述保持堆的性质的过程的时间复杂度为O(h)，h为树的高度。<br>接下来利用keep_max_heap过程将一个数组构建成最大堆：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">build_max_heap</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>{
  <span class="keyword">int</span> i;
  <span class="keyword">int</span> heap_size=n;
  <span class="comment">//从第最后一个非叶结点开始，依次构建调用keep_max_heap过程</span>
  <span class="comment">//可以证明，n/2为最后一个非叶节点</span>
  <span class="keyword">for</span>(i=n/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)  
    keep_max_heap(A,i,heap_size,n);
}
</code></pre><p>build_max_heap过程的时间复杂度为O(N)，详细的证明过程可以参考《算法导论》一书。<br>堆排序函数：</p>
<pre><code>void HeapSort(int <span class="literal">A</span>[], int n){
  int heap_size=n<span class="comment">;</span>
  build_max_heap(<span class="literal">A</span>,n)<span class="comment">;</span>
  int temp<span class="comment">;</span>
  <span class="keyword">while</span>(heap_size&gt;<span class="number">1</span>){
    temp=<span class="literal">A</span>[<span class="number">0</span>]<span class="comment">;</span>
    <span class="literal">A</span>[<span class="number">0</span>]=<span class="literal">A</span>[heap_size-<span class="number">1</span>]<span class="comment">;</span>
    <span class="literal">A</span>[heap_size-<span class="number">1</span>]=temp<span class="comment">;</span>
    keep_max_heap(<span class="literal">A</span>,<span class="number">0</span>,heap_size-<span class="number">1</span>,n)<span class="comment">;</span>
    heap_size--<span class="comment">;</span>
  }
}
</code></pre><p>堆排序的时间复杂度为O(N*logN),空间复杂度为O(1),排序不稳定。</p>
<h3 id="快速排序">快速排序</h3><p>快速排序是实际使用中非常重要的一种排序算法，它最坏情况下的时间复杂度为O(N^2)，但是平均时间复杂度为O(N*logN),快速排序的一种好的实现比堆排序和归并排序都要快。<br>快速排序也是基于分治的思想，先将整个数组用一个元素划分，使该元素左边的部分都比它小，使右边的部分都比它大，然后对左右两边的数组递归调用快速排序自身。快速最重要的部分是划分过程：</p>
<pre><code>int <span class="type">Partion</span>(int <span class="type">A</span>[], int <span class="keyword">left</span>, int <span class="keyword">right</span>){
  int center=(<span class="keyword">left</span>+<span class="keyword">right</span>)/<span class="number">2</span>;
  <span class="keyword">if</span> (<span class="type">A</span>[<span class="keyword">left</span>]&gt;<span class="type">A</span>[center])  <span class="built_in">swap</span>(&amp;<span class="type">A</span>[<span class="keyword">left</span>],&amp;<span class="type">A</span>[center]);
  <span class="keyword">if</span> (<span class="type">A</span>[<span class="keyword">left</span>]&gt;<span class="type">A</span>[<span class="keyword">right</span>])   <span class="built_in">swap</span>(&amp;<span class="type">A</span>[<span class="keyword">left</span>],&amp;<span class="type">A</span>[<span class="keyword">right</span>]);
  <span class="keyword">if</span> (<span class="type">A</span>[center]&gt;<span class="type">A</span>[<span class="keyword">right</span>]) <span class="built_in">swap</span>(&amp;<span class="type">A</span>[center],&amp;<span class="type">A</span>[<span class="keyword">right</span>]);
  <span class="built_in">swap</span>(&amp;<span class="type">A</span>[center],&amp;<span class="type">A</span>[<span class="keyword">right</span>-<span class="number">1</span>]);
  <span class="keyword">return</span> <span class="type">A</span>[<span class="keyword">right</span>-<span class="number">1</span>];
}
</code></pre><p>快速排序过程：</p>
<pre><code>void quick_sort(int <span class="type">A</span>[], int <span class="keyword">left</span>, int <span class="keyword">right</span>){
  int i,j,mid;
  <span class="keyword">if</span>(<span class="keyword">left</span>+<span class="number">10</span>&lt;<span class="keyword">right</span>){  <span class="comment">//数组元素个数较大时使用快排</span>
    mid=<span class="type">Partion</span>(<span class="type">A</span>,<span class="keyword">left</span>,<span class="keyword">right</span>);
    i=<span class="keyword">left</span>;
    j=<span class="keyword">right</span>-<span class="number">1</span>;
    <span class="keyword">for</span>(;;){
      <span class="comment">//从左往右找到第一个不小于mid的元素</span>
      <span class="comment">//A[right-1]==mid保证了寻找过程不会越界</span>
      <span class="keyword">while</span>(<span class="type">A</span>[++i]&lt;mid) {}  
      <span class="comment">//从右往左找到第一个不大于mid的元素</span>
      <span class="comment">//A[left]&lt;=mid保证了寻找过程不会数组越界</span>
      <span class="keyword">while</span>(<span class="type">A</span>[--j]&gt;mid) {}  
      <span class="comment">//交换</span>
      <span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(&amp;<span class="type">A</span>[i],&amp;<span class="type">A</span>[j]);
      <span class="keyword">else</span> <span class="keyword">break</span>;
    }
    <span class="comment">//把A[right-1]处的值交换到适当的位置</span>
    <span class="built_in">swap</span>(&amp;<span class="type">A</span>[i],&amp;<span class="type">A</span>[<span class="keyword">right</span>-<span class="number">1</span>]);
    <span class="comment">//对子数组调用自身排序</span>
    quick_sort(<span class="type">A</span>,<span class="keyword">left</span>,i-<span class="number">1</span>);
    quick_sort(<span class="type">A</span>,i+<span class="number">1</span>,<span class="keyword">right</span>);
  }
  <span class="keyword">else</span>  <span class="comment">//数组元素较小，使用插入排序</span>
  <span class="type">InsertionSort</span>(<span class="type">A</span>+<span class="keyword">left</span>,<span class="keyword">right</span>-<span class="keyword">left</span>+<span class="number">1</span>);
}
</code></pre><p>快速排序函数：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span>{
  quick_sort(A,<span class="number">0</span>,n-<span class="number">1</span>);
}
</code></pre><p>快速排序其平均时间复杂度为O(N*logN),空间复杂度为O(1),由于其内部循环非常紧凑，所以运行速度比堆排序和归并排序都要快。这里的排序过程对有序数组和数据全部相同的数组排序时的时间复杂度都是O(N*logN)。另外当数组比较小时，采用了插入排序，进一步提升了其性能。     </p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/01/buildYourHexoBlog/">
                使用hexo搭建github.io博客
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-07-01
        </span>

        

        
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>记录一下使用hexo搭建博客的步骤，否则长时间不使用hexo的话就会忘记。</p>
<p>1.安装node和git，拥有github账号。<br>2.安装hexo。<br>3.创建本地hexo文件夹，初始化:<code>hexo init</code>。<br>4.安装依赖:<code>npm install</code>。<br>5.完成本地安装:<code>hexo g</code>,<code>hexo s</code>;打开浏览器<code>127.0.0.1:4000</code>可以看到本地生成的网页内容。<br>6.在github上创建一个name格式为 <code>&#39;用户名&#39;.github.io</code>的仓库，生成测试页面并发步。<br>7.创建SSH keys，并添加到自己的github仓库里，测试是否连接成功。<br>8.配置hexo文件夹下的<code>_config.yml</code>文件，最底下：</p>
<pre><code><span class="attribute">deploy</span>: <span class="string"></span>
  <span class="attribute">type</span>: <span class="string">github</span>
  <span class="attribute">repository</span>: <span class="string">https://github.com/zzwei-/zzwei-.github.io/  //改成自己的用户名</span>
  <span class="attribute">branch</span>: <span class="string">master</span>
</code></pre><p>9.执行<code>hexo g</code> ,<code>hexo d</code>,有可能报错 <code>Error:Deployer not found:github</code>，则执行:  </p>
<p><code>npm install hexo-deployer-git --save</code>  </p>
<p>修改<code>_config.yml</code>文件：  </p>
<pre><code>deploy:
  <span class="class"><span class="keyword">type</span>: <span class="title">git</span></span>
</code></pre><p>再次执行上面的两条命令，在<code>https://yourname.github.io/</code>就可以看到自己的博客了。</p>
<p>本篇博客的内容来自<a href="http://www.cnblogs.com/liulangmao/p/4323064.html" target="_blank" rel="external">http://www.cnblogs.com/liulangmao/p/4323064.html</a>，详细内容请参考此博客。<br>更多hexo的使用教程参考hexo官网：<a href="https://hexo.io/" target="_blank" rel="external">https://hexo.io/</a></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  

        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="赵伟" />
          <p class="site-author-name">赵伟</p>
        </div>
        <p class="site-description motion-element"></p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">2</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">1</span>
              <span class="site-state-item-name">分類</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">2</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>
        
      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">赵伟</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.3"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.3"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.3" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  
  

  




  
  

</body>
</html>
