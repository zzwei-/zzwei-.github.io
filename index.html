
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>ZhaoWei&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="ZhaoWei">
    

    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="ZhaoWei's Blog">
<meta property="og:url" content="http://zzwei-.github.io/index.html">
<meta property="og:site_name" content="ZhaoWei's Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZhaoWei's Blog">
<meta name="twitter:description">

    
    <link rel="alternative" href="/atom.xml" title="ZhaoWei&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="ZhaoWei&#39;s Blog" title="ZhaoWei&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="ZhaoWei&#39;s Blog">ZhaoWei&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About me</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:zzwei-.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/07/05/buildYourHexoBlog/" title="buildYourHexoBlog" itemprop="url">buildYourHexoBlog</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://zzwei-.github.io/about" title="ZhaoWei" target="_blank" itemprop="author">ZhaoWei</a>
		
  <p class="article-time">
    <time datetime="2015-07-05T04:31:39.000Z" itemprop="datePublished"> 發表於 2015-07-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/07/04/sort/" title="排序算法----基于比较的排序" itemprop="url">排序算法----基于比较的排序</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://zzwei-.github.io/about" title="ZhaoWei" target="_blank" itemprop="author">ZhaoWei</a>
		
  <p class="article-time">
    <time datetime="2015-07-04T06:18:53.000Z" itemprop="datePublished"> 發表於 2015-07-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="插入排序">插入排序</h3><p>插入排序的原理很简单很简单，打扑克牌时理牌的思想就是插入排序。</p>
<pre><code><span class="keyword">void</span> InsertionSort(<span class="built_in">int</span> A[], <span class="built_in">int</span> n){  <span class="comment">//对大小为n的整型数组进行排序</span>
  <span class="built_in">int</span> i,j;
  <span class="built_in">int</span> <span class="variable">key</span>;
  <span class="comment">//从第二个元素开始，边比较边移动 </span>
  <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++){
    j=i-<span class="number">1</span>;
    <span class="variable">key</span>=A[i];
    <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; A[j]&gt;<span class="variable">key</span>){
    A[j+<span class="number">1</span>]=A[j];
      j--;
    }
    A[j+<span class="number">1</span>]=<span class="variable">key</span>;
  }    
}   
</code></pre><p>插入排序算法的时间复杂度为O(N^2)，空间复杂度为O(1)，排序稳定。</p>
<h3 id="归并排序">归并排序</h3><p>归并排序利用了分治的思想，先把待排序数组分成两个字数组，子数组排好序后，合并成一个排好序的大数组，而子数组的排序可以递归的调用归并排序算法本身。  </p>
<p>归并排序的关键在于归并过程： </p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span></span>{
  <span class="keyword">int</span> n1=q-p+<span class="number">1</span>;
  <span class="keyword">int</span> n2=r-q;
  <span class="keyword">int</span> i,j,k;
  <span class="comment">//创建两个数组，分别保存待合并的左边和右边的数组。</span>
  <span class="keyword">int</span> *arr1=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>((n1+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));
  <span class="keyword">int</span> *arr2=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>((n2+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));
  <span class="comment">//复制原数组到元素到新创建的数组。</span>
  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n1;i++)  arr1[i]=A[p+i];
  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n2;i++)  arr2[i]=A[q+<span class="number">1</span>+i];
  <span class="comment">//这里关键处，设置了两个"哨兵牌"，简化了后面的归并程。</span>
  arr1[n1]=INT_MAX;
  arr2[n2]=INT_MAX;
  <span class="comment">//归并过程，由于有"哨兵"的存在，不需要判断i,j是否会分别大于n1,n2。</span>
  i=j=<span class="number">0</span>;
  <span class="keyword">for</span>(k=p;k&lt;=r;k++){
    <span class="keyword">if</span>(arr1[i]&lt;=arr2[j]){
      A[k]=arr1[i];
      i++;
    }
    <span class="keyword">else</span>{
      A[k]=arr2[j];
      j++;
    }     
  } 
}
</code></pre><p>利用归并过程对数组进行归并排序：</p>
<pre><code>void merge_sort(<span class="built_in">int</span> A[], <span class="built_in">int</span> low, <span class="built_in">int</span> high){
  <span class="keyword">if</span>(low&lt;high){
     <span class="built_in">int</span> <span class="built_in">mid</span>=(high+low)/<span class="number">2</span>;
     merge_sort(A,low,<span class="built_in">mid</span>);
     merge_sort(A,<span class="built_in">mid</span>+<span class="number">1</span>,high);
     Merge(A,low,<span class="built_in">mid</span>,high);
  }
}
</code></pre><p>归并排序函数：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span>{
  merge_sort(A,<span class="number">0</span>,n-<span class="number">1</span>);
}
</code></pre><p>归并排序算法的时间复杂度为O(N*logN),空间复杂度为O(N),排序稳定。</p>
<h3 id="堆排序">堆排序</h3><p>归并排序的时间复杂度比插入排序小，但是空间复杂度大，堆排序结合了两者的优点。<br>堆排序使用一种叫做(二叉)堆的数据结构，其可以被视作一颗完全二叉树。堆排序的主要过程为保持堆的性质。假设一棵完全二叉树除了根节点之外，其左右子树都是大顶堆，则保持整棵树为大顶堆的过程keep_max_heap为：</p>
<pre><code><span class="comment">//以i为根的二叉数的左右子树都为大顶堆。</span>
<span class="comment">//这个过程使以i为根的整棵树成为大顶堆。    </span>
<span class="function"><span class="keyword">void</span> <span class="title">keep_max_heap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> heap_size, <span class="keyword">int</span> n)</span></span>{ 
  <span class="keyword">int</span> l=<span class="number">2</span>*i; <span class="comment">//左子树的根</span>
  <span class="keyword">int</span> r=<span class="number">2</span>*i+<span class="number">1</span>; <span class="comment">//右子树的根</span>
  <span class="comment">//找出i,l,r值最大的结点</span>
  <span class="keyword">int</span> temp,largest=i;
  <span class="keyword">if</span>(l&lt;heap_size &amp;&amp; A[l]&gt;A[i]){
    largest=l;
  }
  <span class="keyword">if</span>(r&lt;heap_size &amp;&amp; A[r]&gt;A[largest]){
    largest=r;
  }
  <span class="comment">//若根非最大结点，将根的值与最大结点对换，然后递归调用自身保持子树的最大堆性质</span>
  <span class="keyword">if</span>(largest!=i){
    emp=A[i];
    A[i]=A[largest];
    A[largest]=temp;
    keep_max_heap(A,largest,heap_size,n);
  }
}
</code></pre><p>上述保持堆的性质的过程的时间复杂度为O(h)，h为树的高度。<br>接下来利用keep_max_heap过程将一个数组构建成最大堆：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">build_max_heap</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>{
  <span class="keyword">int</span> i;
  <span class="keyword">int</span> heap_size=n;
  <span class="comment">//从第最后一个非叶结点开始，依次构建调用keep_max_heap过程</span>
  <span class="comment">//可以证明，n/2为最后一个非叶节点</span>
  <span class="keyword">for</span>(i=n/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)  
    keep_max_heap(A,i,heap_size,n);
}
</code></pre><p>build_max_heap过程的时间复杂度为O(N)，详细的证明过程可以参考《算法导论》一书。<br>堆排序函数：</p>
<pre><code>void HeapSort(int <span class="literal">A</span>[], int n){
  int heap_size=n<span class="comment">;</span>
  build_max_heap(<span class="literal">A</span>,n)<span class="comment">;</span>
  int temp<span class="comment">;</span>
  <span class="keyword">while</span>(heap_size&gt;<span class="number">1</span>){
    temp=<span class="literal">A</span>[<span class="number">0</span>]<span class="comment">;</span>
    <span class="literal">A</span>[<span class="number">0</span>]=<span class="literal">A</span>[heap_size-<span class="number">1</span>]<span class="comment">;</span>
    <span class="literal">A</span>[heap_size-<span class="number">1</span>]=temp<span class="comment">;</span>
    keep_max_heap(<span class="literal">A</span>,<span class="number">0</span>,heap_size-<span class="number">1</span>,n)<span class="comment">;</span>
    heap_size--<span class="comment">;</span>
  }
}
</code></pre><p>堆排序的时间复杂度为O(N*logN),空间复杂度为O(1),排序不稳定。</p>
<h3 id="快速排序">快速排序</h3><p>快速排序是实际使用中非常重要的一种排序算法，它最坏情况下的时间复杂度为O(N^2)，但是平均时间复杂度为O(N*logN),快速排序的一种好的实现比堆排序和归并排序都要快。<br>快速排序也是基于分治的思想，先将整个数组用一个元素划分，使该元素左边的部分都比它小，使右边的部分都比它大，然后对左右两边的数组递归调用快速排序自身。快速最重要的部分是划分过程：</p>
<pre><code>int <span class="type">Partion</span>(int <span class="type">A</span>[], int <span class="keyword">left</span>, int <span class="keyword">right</span>){
  int center=(<span class="keyword">left</span>+<span class="keyword">right</span>)/<span class="number">2</span>;
  <span class="keyword">if</span> (<span class="type">A</span>[<span class="keyword">left</span>]&gt;<span class="type">A</span>[center])  <span class="built_in">swap</span>(&amp;<span class="type">A</span>[<span class="keyword">left</span>],&amp;<span class="type">A</span>[center]);
  <span class="keyword">if</span> (<span class="type">A</span>[<span class="keyword">left</span>]&gt;<span class="type">A</span>[<span class="keyword">right</span>])   <span class="built_in">swap</span>(&amp;<span class="type">A</span>[<span class="keyword">left</span>],&amp;<span class="type">A</span>[<span class="keyword">right</span>]);
  <span class="keyword">if</span> (<span class="type">A</span>[center]&gt;<span class="type">A</span>[<span class="keyword">right</span>]) <span class="built_in">swap</span>(&amp;<span class="type">A</span>[center],&amp;<span class="type">A</span>[<span class="keyword">right</span>]);
  <span class="built_in">swap</span>(&amp;<span class="type">A</span>[center],&amp;<span class="type">A</span>[<span class="keyword">right</span>-<span class="number">1</span>]);
  <span class="keyword">return</span> <span class="type">A</span>[<span class="keyword">right</span>-<span class="number">1</span>];
}
</code></pre><p>快速排序过程：</p>
<pre><code>void quick_sort(int <span class="type">A</span>[], int <span class="keyword">left</span>, int <span class="keyword">right</span>){
  int i,j,mid;
  <span class="keyword">if</span>(<span class="keyword">left</span>+<span class="number">10</span>&lt;<span class="keyword">right</span>){  <span class="comment">//数组元素个数较大时使用快排</span>
    mid=<span class="type">Partion</span>(<span class="type">A</span>,<span class="keyword">left</span>,<span class="keyword">right</span>);
    i=<span class="keyword">left</span>;
    j=<span class="keyword">right</span>-<span class="number">1</span>;
    <span class="keyword">for</span>(;;){
      <span class="comment">//从左往右找到第一个不小于mid的元素</span>
      <span class="comment">//A[right-1]==mid保证了寻找过程不会越界</span>
      <span class="keyword">while</span>(<span class="type">A</span>[++i]&lt;mid) {}  
      <span class="comment">//从右往左找到第一个不大于mid的元素</span>
      <span class="comment">//A[left]&lt;=mid保证了寻找过程不会数组越界</span>
      <span class="keyword">while</span>(<span class="type">A</span>[--j]&gt;mid) {}  
      <span class="comment">//交换</span>
      <span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(&amp;<span class="type">A</span>[i],&amp;<span class="type">A</span>[j]);
      <span class="keyword">else</span> <span class="keyword">break</span>;
    }
    <span class="comment">//把A[right-1]处的值交换到适当的位置</span>
    <span class="built_in">swap</span>(&amp;<span class="type">A</span>[i],&amp;<span class="type">A</span>[<span class="keyword">right</span>-<span class="number">1</span>]);
    <span class="comment">//对子数组调用自身排序</span>
    quick_sort(<span class="type">A</span>,<span class="keyword">left</span>,i-<span class="number">1</span>);
    quick_sort(<span class="type">A</span>,i+<span class="number">1</span>,<span class="keyword">right</span>);
  }
  <span class="keyword">else</span>  <span class="comment">//数组元素较小，使用插入排序</span>
  <span class="type">InsertionSort</span>(<span class="type">A</span>+<span class="keyword">left</span>,<span class="keyword">right</span>-<span class="keyword">left</span>+<span class="number">1</span>);
}
</code></pre><p>快速排序函数：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span>{
  quick_sort(A,<span class="number">0</span>,n-<span class="number">1</span>);
}
</code></pre><p>快速排序其平均时间复杂度为O(N*logN),空间复杂度为O(1),由于其内部循环非常紧凑，所以运行速度比堆排序和归并排序都要快。这里的排序过程对有序数组和数据全部相同的数组排序时的时间复杂度都是O(N*logN)。另外当数组比较小时，采用了插入排序，进一步提升了其性能。     </p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据结构和算法/">数据结构和算法</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







</div>
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分類</p>
		<ul>
		
		  
			<li><a href="/categories/数据结构和算法/" title="数据结构和算法">数据结构和算法<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">標簽</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情鏈接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.fatalfault.com/" target="_blank" title="Riemann.Gan&#39;s blog">Riemann.Gan&#39;s blog</a>
            
          </li>
        
          <li>
            
            	<a href="https://www-roway.rhcloud.com/" target="_blank" title="Roway&#39;s blog">Roway&#39;s blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="http://zzwei-.github.io/about" target="_blank" title="ZhaoWei">ZhaoWei</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回頂部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
